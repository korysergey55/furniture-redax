{"version":3,"file":"static/js/233.ccf6811d.chunk.js","mappings":"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","sources":["../node_modules/mobx-react-lite/src/utils/assertEnvironment.ts","../node_modules/mobx-react-lite/src/utils/observerBatching.ts","../node_modules/mobx-react-lite/src/utils/printDebugValue.ts","../node_modules/mobx-react-lite/src/staticRendering.ts","../node_modules/mobx-react-lite/src/utils/UniversalFinalizationRegistry.ts","../node_modules/mobx-react-lite/src/utils/observerFinalizationRegistry.ts","../node_modules/mobx-react-lite/src/useObserver.ts","../node_modules/mobx-react-lite/src/observer.ts","../node_modules/mobx-react-lite/src/index.ts","../node_modules/mobx-react/src/utils/utils.ts","../node_modules/mobx-react/src/observerClass.ts","../node_modules/mobx-react/src/observer.tsx","../node_modules/mobx-react/src/disposeOnUnmount.ts","../node_modules/mobx-react/src/index.ts","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../node_modules/use-sync-external-store/shim/index.js"],"sourcesContent":["import { makeObservable } from \"mobx\"\nimport { useState } from \"react\"\n\nif (!useState) {\n    throw new Error(\"mobx-react-lite requires React with Hooks support\")\n}\nif (!makeObservable) {\n    throw new Error(\"mobx-react-lite@3 requires mobx at least version 6 to be available\")\n}\n","import { configure } from \"mobx\"\n\nexport function defaultNoopBatch(callback: () => void) {\n    callback()\n}\n\nexport function observerBatching(reactionScheduler: any) {\n    if (!reactionScheduler) {\n        reactionScheduler = defaultNoopBatch\n        if (\"production\" !== process.env.NODE_ENV) {\n            console.warn(\n                \"[MobX] Failed to get unstable_batched updates from react-dom / react-native\"\n            )\n        }\n    }\n    configure({ reactionScheduler })\n}\n\nexport const isObserverBatched = () => {\n    if (\"production\" !== process.env.NODE_ENV) {\n        console.warn(\"[MobX] Deprecated\")\n    }\n\n    return true\n}\n","import { getDependencyTree, Reaction } from \"mobx\"\n\nexport function printDebugValue(v: Reaction) {\n    return getDependencyTree(v)\n}\n","let globalIsUsingStaticRendering = false\n\nexport function enableStaticRendering(enable: boolean) {\n    globalIsUsingStaticRendering = enable\n}\n\nexport function isUsingStaticRendering(): boolean {\n    return globalIsUsingStaticRendering\n}\n","export declare class FinalizationRegistryType<T> {\n    constructor(finalize: (value: T) => void)\n    register(target: object, value: T, token?: object): void\n    unregister(token: object): void\n}\n\ndeclare const FinalizationRegistry: typeof FinalizationRegistryType | undefined\n\nexport const REGISTRY_FINALIZE_AFTER = 10_000\nexport const REGISTRY_SWEEP_INTERVAL = 10_000\n\nexport class TimerBasedFinalizationRegistry<T> implements FinalizationRegistryType<T> {\n    private registrations: Map<unknown, { value: T; registeredAt: number }> = new Map()\n    private sweepTimeout: ReturnType<typeof setTimeout> | undefined\n\n    constructor(private readonly finalize: (value: T) => void) {}\n\n    // Token is actually required with this impl\n    register(target: object, value: T, token?: object) {\n        this.registrations.set(token, {\n            value,\n            registeredAt: Date.now()\n        })\n        this.scheduleSweep()\n    }\n\n    unregister(token: unknown) {\n        this.registrations.delete(token)\n    }\n\n    // Bound so it can be used directly as setTimeout callback.\n    sweep = (maxAge = REGISTRY_FINALIZE_AFTER) => {\n        // cancel timeout so we can force sweep anytime\n        clearTimeout(this.sweepTimeout)\n        this.sweepTimeout = undefined\n\n        const now = Date.now()\n        this.registrations.forEach((registration, token) => {\n            if (now - registration.registeredAt >= maxAge) {\n                this.finalize(registration.value)\n                this.registrations.delete(token)\n            }\n        })\n\n        if (this.registrations.size > 0) {\n            this.scheduleSweep()\n        }\n    }\n\n    // Bound so it can be exported directly as clearTimers test utility.\n    finalizeAllImmediately = () => {\n        this.sweep(0)\n    }\n\n    private scheduleSweep() {\n        if (this.sweepTimeout === undefined) {\n            this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL)\n        }\n    }\n}\n\nexport const UniversalFinalizationRegistry =\n    typeof FinalizationRegistry !== \"undefined\"\n        ? FinalizationRegistry\n        : TimerBasedFinalizationRegistry\n","import { Reaction } from \"mobx\"\nimport { UniversalFinalizationRegistry } from \"./UniversalFinalizationRegistry\"\n\nexport const observerFinalizationRegistry = new UniversalFinalizationRegistry(\n    (adm: { reaction: Reaction | null }) => {\n        adm.reaction?.dispose()\n        adm.reaction = null\n    }\n)\n","import { Reaction } from \"mobx\"\nimport React from \"react\"\nimport { printDebugValue } from \"./utils/printDebugValue\"\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\"\nimport { useSyncExternalStore } from \"use-sync-external-store/shim\"\n\n// Do not store `admRef` (even as part of a closure!) on this object,\n// otherwise it will prevent GC and therefore reaction disposal via FinalizationRegistry.\ntype ObserverAdministration = {\n    reaction: Reaction | null // also serves as disposed flag\n    onStoreChange: Function | null // also serves as mounted flag\n    // stateVersion that 'ticks' for every time the reaction fires\n    // tearing is still present,\n    // because there is no cross component synchronization,\n    // but we can use `useSyncExternalStore` API.\n    // TODO: optimize to use number?\n    stateVersion: any\n    name: string\n    // These don't depend on state/props, therefore we can keep them here instead of `useCallback`\n    subscribe: Parameters<typeof React.useSyncExternalStore>[0]\n    getSnapshot: Parameters<typeof React.useSyncExternalStore>[1]\n}\n\nfunction createReaction(adm: ObserverAdministration) {\n    adm.reaction = new Reaction(`observer${adm.name}`, () => {\n        adm.stateVersion = Symbol()\n        // onStoreChange won't be available until the component \"mounts\".\n        // If state changes in between initial render and mount,\n        // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n        adm.onStoreChange?.()\n    })\n}\n\nexport function useObserver<T>(render: () => T, baseComponentName: string = \"observed\"): T {\n    if (isUsingStaticRendering()) {\n        return render()\n    }\n\n    const admRef = React.useRef<ObserverAdministration | null>(null)\n\n    if (!admRef.current) {\n        // First render\n        const adm: ObserverAdministration = {\n            reaction: null,\n            onStoreChange: null,\n            stateVersion: Symbol(),\n            name: baseComponentName,\n            subscribe(onStoreChange: () => void) {\n                // Do NOT access admRef here!\n                observerFinalizationRegistry.unregister(adm)\n                adm.onStoreChange = onStoreChange\n                if (!adm.reaction) {\n                    // We've lost our reaction and therefore all subscriptions, occurs when:\n                    // 1. Timer based finalization registry disposed reaction before component mounted.\n                    // 2. React \"re-mounts\" same component without calling render in between (typically <StrictMode>).\n                    // We have to recreate reaction and schedule re-render to recreate subscriptions,\n                    // even if state did not change.\n                    createReaction(adm)\n                    // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.\n                    // So we make sure that is not the case\n                    adm.stateVersion = Symbol()\n                }\n\n                return () => {\n                    // Do NOT access admRef here!\n                    adm.onStoreChange = null\n                    adm.reaction?.dispose()\n                    adm.reaction = null\n                }\n            },\n            getSnapshot() {\n                // Do NOT access admRef here!\n                return adm.stateVersion\n            }\n        }\n\n        admRef.current = adm\n    }\n\n    const adm = admRef.current!\n\n    if (!adm.reaction) {\n        // First render or reaction was disposed by registry before subscribe\n        createReaction(adm)\n        // StrictMode/ConcurrentMode/Suspense may mean that our component is\n        // rendered and abandoned multiple times, so we need to track leaked\n        // Reactions.\n        observerFinalizationRegistry.register(admRef, adm, adm)\n    }\n\n    React.useDebugValue(adm.reaction!, printDebugValue)\n\n    useSyncExternalStore(\n        // Both of these must be stable, otherwise it would keep resubscribing every render.\n        adm.subscribe,\n        adm.getSnapshot,\n        adm.getSnapshot\n    )\n\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    let renderResult!: T\n    let exception\n    adm.reaction!.track(() => {\n        try {\n            renderResult = render()\n        } catch (e) {\n            exception = e\n        }\n    })\n\n    if (exception) {\n        throw exception // re-throw any exceptions caught during rendering\n    }\n\n    return renderResult\n}\n","import { forwardRef, memo } from \"react\"\n\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { useObserver } from \"./useObserver\"\n\nlet warnObserverOptionsDeprecated = true\n\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for\nconst isFunctionNameConfigurable =\n    Object.getOwnPropertyDescriptor(() => {}, \"name\")?.configurable ?? false\n\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nconst ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof forwardRef === \"function\" && forwardRef((props: any) => null)[\"$$typeof\"]\n\nconst ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof memo === \"function\" && memo((props: any) => null)[\"$$typeof\"]\n\nexport interface IObserverOptions {\n    readonly forwardRef?: boolean\n}\n\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.ForwardRefRenderFunction<TRef, P>,\n    options: IObserverOptions & { forwardRef: true }\n): React.MemoExoticComponent<\n    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>\n>\n\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.ForwardRefExoticComponent<\n        React.PropsWithoutRef<P> & React.RefAttributes<TRef>\n    >\n): React.MemoExoticComponent<\n    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>\n>\n\nexport function observer<P extends object>(\n    baseComponent: React.FunctionComponent<P>,\n    options?: IObserverOptions\n): React.FunctionComponent<P>\n\nexport function observer<\n    C extends React.FunctionComponent<any> | React.ForwardRefRenderFunction<any>,\n    Options extends IObserverOptions\n>(\n    baseComponent: C,\n    options?: Options\n): Options extends { forwardRef: true }\n    ? C extends React.ForwardRefRenderFunction<infer TRef, infer P>\n        ? C &\n              React.MemoExoticComponent<\n                  React.ForwardRefExoticComponent<\n                      React.PropsWithoutRef<P> & React.RefAttributes<TRef>\n                  >\n              >\n        : never /* forwardRef set for a non forwarding component */\n    : C & { displayName: string }\n\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer<P extends object, TRef = {}>(\n    baseComponent:\n        | React.ForwardRefRenderFunction<TRef, P>\n        | React.FunctionComponent<P>\n        | React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>,\n    // TODO remove in next major\n    options?: IObserverOptions\n) {\n    if (process.env.NODE_ENV !== \"production\" && warnObserverOptionsDeprecated && options) {\n        warnObserverOptionsDeprecated = false\n        console.warn(\n            `[mobx-react-lite] \\`observer(fn, { forwardRef: true })\\` is deprecated, use \\`observer(React.forwardRef(fn))\\``\n        )\n    }\n\n    if (ReactMemoSymbol && baseComponent[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\n            `[mobx-react-lite] You are trying to use \\`observer\\` on a function component wrapped in either another \\`observer\\` or \\`React.memo\\`. The observer already applies 'React.memo' for you.`\n        )\n    }\n\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent\n    }\n\n    let useForwardRef = options?.forwardRef ?? false\n    let render = baseComponent\n\n    const baseComponentName = baseComponent.displayName || baseComponent.name\n\n    // If already wrapped with forwardRef, unwrap,\n    // so we can patch render and apply memo\n    if (ReactForwardRefSymbol && baseComponent[\"$$typeof\"] === ReactForwardRefSymbol) {\n        useForwardRef = true\n        render = baseComponent[\"render\"]\n        if (typeof render !== \"function\") {\n            throw new Error(\n                `[mobx-react-lite] \\`render\\` property of ForwardRef was not a function`\n            )\n        }\n    }\n\n    let observerComponent = (props: any, ref: React.Ref<TRef>) => {\n        return useObserver(() => render(props, ref), baseComponentName)\n    }\n\n    // Inherit original name and displayName, see #3438\n    ;(observerComponent as React.FunctionComponent).displayName = baseComponent.displayName\n\n    if (isFunctionNameConfigurable) {\n        Object.defineProperty(observerComponent, \"name\", {\n            value: baseComponent.name,\n            writable: true,\n            configurable: true\n        })\n    }\n\n    // Support legacy context: `contextTypes` must be applied before `memo`\n    if ((baseComponent as any).contextTypes) {\n        ;(observerComponent as React.FunctionComponent).contextTypes = (\n            baseComponent as any\n        ).contextTypes\n    }\n\n    if (useForwardRef) {\n        // `forwardRef` must be applied prior `memo`\n        // `forwardRef(observer(cmp))` throws:\n        // \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\n        observerComponent = forwardRef(observerComponent)\n    }\n\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    observerComponent = memo(observerComponent)\n\n    copyStaticProperties(baseComponent, observerComponent)\n\n    if (\"production\" !== process.env.NODE_ENV) {\n        Object.defineProperty(observerComponent, \"contextTypes\", {\n            set() {\n                throw new Error(\n                    `[mobx-react-lite] \\`${\n                        this.displayName || this.type?.displayName || this.type?.name || \"Component\"\n                    }.contextTypes\\` must be set before applying \\`observer\\`.`\n                )\n            }\n        })\n    }\n\n    return observerComponent\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList: any = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true,\n    // Don't redefine `displayName`,\n    // it's defined as getter-setter pair on `memo` (see #3192).\n    displayName: true\n}\n\nfunction copyStaticProperties(base: any, target: any) {\n    Object.keys(base).forEach(key => {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)\n        }\n    })\n}\n","import \"./utils/assertEnvironment\"\n\nimport { unstable_batchedUpdates as batch } from \"./utils/reactBatchedUpdates\"\nimport { observerBatching } from \"./utils/observerBatching\"\nimport { useDeprecated } from \"./utils/utils\"\nimport { useObserver as useObserverOriginal } from \"./useObserver\"\nimport { enableStaticRendering } from \"./staticRendering\"\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\"\n\nobserverBatching(batch)\n\nexport { isUsingStaticRendering, enableStaticRendering } from \"./staticRendering\"\nexport { observer, IObserverOptions } from \"./observer\"\nexport { Observer } from \"./ObserverComponent\"\nexport { useLocalObservable } from \"./useLocalObservable\"\nexport { useLocalStore } from \"./useLocalStore\"\nexport { useAsObservableSource } from \"./useAsObservableSource\"\n\nexport { observerFinalizationRegistry as _observerFinalizationRegistry }\nexport const clearTimers = observerFinalizationRegistry[\"finalizeAllImmediately\"] ?? (() => {})\n\nexport function useObserver<T>(fn: () => T, baseComponentName: string = \"observed\"): T {\n    if (\"production\" !== process.env.NODE_ENV) {\n        useDeprecated(\n            \"[mobx-react-lite] 'useObserver(fn)' is deprecated. Use `<Observer>{fn}</Observer>` instead, or wrap the entire component in `observer`.\"\n        )\n    }\n    return useObserverOriginal(fn, baseComponentName)\n}\n\nexport { isObserverBatched, observerBatching } from \"./utils/observerBatching\"\n\nexport function useStaticRendering(enable: boolean) {\n    if (\"production\" !== process.env.NODE_ENV) {\n        console.warn(\n            \"[mobx-react-lite] 'useStaticRendering' is deprecated, use 'enableStaticRendering' instead\"\n        )\n    }\n    enableStaticRendering(enable)\n}\n","export function shallowEqual(objA: any, objB: any): boolean {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) {\n        return true\n    }\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) {\n        return false\n    }\n    for (let i = 0; i < keysA.length; i++) {\n        if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction is(x: any, y: any): boolean {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList = {\n    $$typeof: 1,\n    render: 1,\n    compare: 1,\n    type: 1,\n    childContextTypes: 1,\n    contextType: 1,\n    contextTypes: 1,\n    defaultProps: 1,\n    getDefaultProps: 1,\n    getDerivedStateFromError: 1,\n    getDerivedStateFromProps: 1,\n    mixins: 1,\n    displayName: 1,\n    propTypes: 1\n}\n\nexport function copyStaticProperties(base: object, target: object): void {\n    const protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base))\n    Object.getOwnPropertyNames(base).forEach(key => {\n        if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)\n        }\n    })\n}\n\n/**\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\n * @param target\n * @param prop\n * @param value\n */\nexport function setHiddenProp(target: object, prop: any, value: any): void {\n    if (!Object.hasOwnProperty.call(target, prop)) {\n        Object.defineProperty(target, prop, {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value\n        })\n    } else {\n        target[prop] = value\n    }\n}\n\n/**\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\n * and the handler provided by mobx-react\n */\nconst mobxMixins = Symbol(\"patchMixins\")\nconst mobxPatchedDefinition = Symbol(\"patchedDefinition\")\n\nexport interface Mixins extends Record<string, any> {\n    locks: number\n    methods: Array<Function>\n}\n\nfunction getMixins(target: object, methodName: string): Mixins {\n    const mixins = (target[mobxMixins] = target[mobxMixins] || {})\n    const methodMixins = (mixins[methodName] = mixins[methodName] || {})\n    methodMixins.locks = methodMixins.locks || 0\n    methodMixins.methods = methodMixins.methods || []\n    return methodMixins\n}\n\nfunction wrapper(realMethod: Function, mixins: Mixins, ...args: Array<any>) {\n    // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\n    mixins.locks++\n\n    try {\n        let retVal\n        if (realMethod !== undefined && realMethod !== null) {\n            retVal = realMethod.apply(this, args)\n        }\n\n        return retVal\n    } finally {\n        mixins.locks--\n        if (mixins.locks === 0) {\n            mixins.methods.forEach(mx => {\n                mx.apply(this, args)\n            })\n        }\n    }\n}\n\nfunction wrapFunction(realMethod: Function, mixins: Mixins): (...args: Array<any>) => any {\n    const fn = function (...args: Array<any>) {\n        wrapper.call(this, realMethod, mixins, ...args)\n    }\n    return fn\n}\n\nexport function patch(target: object, methodName: string, mixinMethod: Function): void {\n    const mixins = getMixins(target, methodName)\n\n    if (mixins.methods.indexOf(mixinMethod) < 0) {\n        mixins.methods.push(mixinMethod)\n    }\n\n    const oldDefinition = Object.getOwnPropertyDescriptor(target, methodName)\n    if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\n        // already patched definition, do not repatch\n        return\n    }\n\n    const originalMethod = target[methodName]\n    const newDefinition = createDefinition(\n        target,\n        methodName,\n        oldDefinition ? oldDefinition.enumerable : undefined,\n        mixins,\n        originalMethod\n    )\n\n    Object.defineProperty(target, methodName, newDefinition)\n}\n\nfunction createDefinition(\n    target: object,\n    methodName: string,\n    enumerable: any,\n    mixins: Mixins,\n    originalMethod: Function\n): PropertyDescriptor {\n    let wrappedFunc = wrapFunction(originalMethod, mixins)\n\n    return {\n        // @ts-ignore\n        [mobxPatchedDefinition]: true,\n        get: function () {\n            return wrappedFunc\n        },\n        set: function (value) {\n            if (this === target) {\n                wrappedFunc = wrapFunction(value, mixins)\n            } else {\n                // when it is an instance of the prototype/a child prototype patch that particular case again separately\n                // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\n                // e.g. the method for super might not be the same as the method for the prototype which might be not the same\n                // as the method for the instance\n                const newDefinition = createDefinition(this, methodName, enumerable, mixins, value)\n                Object.defineProperty(this, methodName, newDefinition)\n            }\n        },\n        configurable: true,\n        enumerable: enumerable\n    }\n}\n","import { PureComponent, Component, ComponentClass, ClassAttributes } from \"react\"\nimport {\n    _allowStateChanges,\n    Reaction,\n    _allowStateReadsStart,\n    _allowStateReadsEnd,\n    _getGlobalState\n} from \"mobx\"\nimport {\n    isUsingStaticRendering,\n    _observerFinalizationRegistry as observerFinalizationRegistry\n} from \"mobx-react-lite\"\nimport { shallowEqual, patch } from \"./utils/utils\"\n\nconst administrationSymbol = Symbol(\"ObserverAdministration\")\nconst isMobXReactObserverSymbol = Symbol(\"isMobXReactObserver\")\n\nlet observablePropDescriptors: PropertyDescriptorMap\nif (__DEV__) {\n    observablePropDescriptors = {\n        props: createObservablePropDescriptor(\"props\"),\n        state: createObservablePropDescriptor(\"state\"),\n        context: createObservablePropDescriptor(\"context\")\n    }\n}\n\ntype ObserverAdministration = {\n    reaction: Reaction | null // also serves as disposed flag\n    forceUpdate: Function | null\n    mounted: boolean // we could use forceUpdate as mounted flag\n    reactionInvalidatedBeforeMount: boolean\n    name: string\n    // Used only on __DEV__\n    props: any\n    state: any\n    context: any\n}\n\nfunction getAdministration(component: Component): ObserverAdministration {\n    // We create administration lazily, because we can't patch constructor\n    // and the exact moment of initialization partially depends on React internals.\n    // At the time of writing this, the first thing invoked is one of the observable getter/setter (state/props/context).\n    return (component[administrationSymbol] ??= {\n        reaction: null,\n        mounted: false,\n        reactionInvalidatedBeforeMount: false,\n        forceUpdate: null,\n        name: getDisplayName(component.constructor as ComponentClass),\n        state: undefined,\n        props: undefined,\n        context: undefined\n    })\n}\n\nexport function makeClassComponentObserver(\n    componentClass: ComponentClass<any, any>\n): ComponentClass<any, any> {\n    const { prototype } = componentClass\n\n    if (componentClass[isMobXReactObserverSymbol]) {\n        const displayName = getDisplayName(componentClass)\n        throw new Error(\n            `The provided component class (${displayName}) has already been declared as an observer component.`\n        )\n    } else {\n        componentClass[isMobXReactObserverSymbol] = true\n    }\n\n    if (prototype.componentWillReact) {\n        throw new Error(\"The componentWillReact life-cycle event is no longer supported\")\n    }\n    if (componentClass[\"__proto__\"] !== PureComponent) {\n        if (!prototype.shouldComponentUpdate) {\n            prototype.shouldComponentUpdate = observerSCU\n        } else if (prototype.shouldComponentUpdate !== observerSCU) {\n            // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\n            throw new Error(\n                \"It is not allowed to use shouldComponentUpdate in observer based components.\"\n            )\n        }\n    }\n\n    if (__DEV__) {\n        Object.defineProperties(prototype, observablePropDescriptors)\n    }\n\n    const originalRender = prototype.render\n    if (typeof originalRender !== \"function\") {\n        const displayName = getDisplayName(componentClass)\n        throw new Error(\n            `[mobx-react] class component (${displayName}) is missing \\`render\\` method.` +\n                `\\n\\`observer\\` requires \\`render\\` being a function defined on prototype.` +\n                `\\n\\`render = () => {}\\` or \\`render = function() {}\\` is not supported.`\n        )\n    }\n\n    prototype.render = function () {\n        Object.defineProperty(this, \"render\", {\n            // There is no safe way to replace render, therefore it's forbidden.\n            configurable: false,\n            writable: false,\n            value: isUsingStaticRendering()\n                ? originalRender\n                : createReactiveRender.call(this, originalRender)\n        })\n        return this.render()\n    }\n\n    const originalComponentDidMount = prototype.componentDidMount\n    prototype.componentDidMount = function () {\n        if (__DEV__ && this.componentDidMount !== Object.getPrototypeOf(this).componentDidMount) {\n            const displayName = getDisplayName(componentClass)\n            throw new Error(\n                `[mobx-react] \\`observer(${displayName}).componentDidMount\\` must be defined on prototype.` +\n                    `\\n\\`componentDidMount = () => {}\\` or \\`componentDidMount = function() {}\\` is not supported.`\n            )\n        }\n\n        // `componentDidMount` may not be called at all. React can abandon the instance after `render`.\n        // That's why we use finalization registry to dispose reaction created during render.\n        // Happens with `<Suspend>` see #3492\n        //\n        // `componentDidMount` can be called immediately after `componentWillUnmount` without calling `render` in between.\n        // Happens with `<StrictMode>`see #3395.\n        //\n        // If `componentDidMount` is called, it's guaranteed to run synchronously with render (similary to `useLayoutEffect`).\n        // Therefore we don't have to worry about external (observable) state being updated before mount (no state version checking).\n        //\n        // Things may change: \"In the future, React will provide a feature that lets components preserve state between unmounts\"\n\n        const admin = getAdministration(this)\n\n        admin.mounted = true\n\n        // Component instance committed, prevent reaction disposal.\n        observerFinalizationRegistry.unregister(this)\n\n        // We don't set forceUpdate before mount because it requires a reference to `this`,\n        // therefore `this` could NOT be garbage collected before mount,\n        // preventing reaction disposal by FinalizationRegistry and leading to memory leak.\n        // As an alternative we could have `admin.instanceRef = new WeakRef(this)`, but lets avoid it if possible.\n        admin.forceUpdate = () => this.forceUpdate()\n\n        if (!admin.reaction || admin.reactionInvalidatedBeforeMount) {\n            // Missing reaction:\n            // 1. Instance was unmounted (reaction disposed) and immediately remounted without running render #3395.\n            // 2. Reaction was disposed by finalization registry before mount. Shouldn't ever happen for class components:\n            // `componentDidMount` runs synchronously after render, but our registry are deferred (can't run in between).\n            // In any case we lost subscriptions to observables, so we have to create new reaction and re-render to resubscribe.\n            // The reaction will be created lazily by following render.\n\n            // Reaction invalidated before mount:\n            // 1. A descendant's `componenDidMount` invalidated it's parent #3730\n\n            admin.forceUpdate()\n        }\n        return originalComponentDidMount?.apply(this, arguments)\n    }\n\n    // TODO@major Overly complicated \"patch\" is only needed to support the deprecated @disposeOnUnmount\n    patch(prototype, \"componentWillUnmount\", function () {\n        if (isUsingStaticRendering()) {\n            return\n        }\n        const admin = getAdministration(this)\n        admin.reaction?.dispose()\n        admin.reaction = null\n        admin.forceUpdate = null\n        admin.mounted = false\n        admin.reactionInvalidatedBeforeMount = false\n    })\n\n    return componentClass\n}\n\n// Generates a friendly name for debugging\nfunction getDisplayName(componentClass: ComponentClass) {\n    return componentClass.displayName || componentClass.name || \"<component>\"\n}\n\nfunction createReactiveRender(originalRender: any) {\n    const boundOriginalRender = originalRender.bind(this)\n\n    const admin = getAdministration(this)\n\n    function reactiveRender() {\n        if (!admin.reaction) {\n            // Create reaction lazily to support re-mounting #3395\n            admin.reaction = createReaction(admin)\n            if (!admin.mounted) {\n                // React can abandon this instance and never call `componentDidMount`/`componentWillUnmount`,\n                // we have to make sure reaction will be disposed.\n                observerFinalizationRegistry.register(this, admin, this)\n            }\n        }\n\n        let error: unknown = undefined\n        let renderResult = undefined\n        admin.reaction.track(() => {\n            try {\n                // TODO@major\n                // Optimization: replace with _allowStateChangesStart/End (not available in mobx@6.0.0)\n                renderResult = _allowStateChanges(false, boundOriginalRender)\n            } catch (e) {\n                error = e\n            }\n        })\n        if (error) {\n            throw error\n        }\n        return renderResult\n    }\n\n    return reactiveRender\n}\n\nfunction createReaction(admin: ObserverAdministration) {\n    return new Reaction(`${admin.name}.render()`, () => {\n        if (!admin.mounted) {\n            // This is neccessary to avoid react warning about calling forceUpdate on component that isn't mounted yet.\n            // This happens when component is abandoned after render - our reaction is already created and reacts to changes.\n            // `componenDidMount` runs synchronously after `render`, so unlike functional component, there is no delay during which the reaction could be invalidated.\n            // However `componentDidMount` runs AFTER it's descendants' `componentDidMount`, which CAN invalidate the reaction, see #3730. Therefore remember and forceUpdate on mount.\n            admin.reactionInvalidatedBeforeMount = true\n            return\n        }\n\n        try {\n            admin.forceUpdate?.()\n        } catch (error) {\n            admin.reaction?.dispose()\n            admin.reaction = null\n        }\n    })\n}\n\nfunction observerSCU(nextProps: ClassAttributes<any>, nextState: any): boolean {\n    if (isUsingStaticRendering()) {\n        console.warn(\n            \"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\"\n        )\n    }\n    // update on any state changes (as is the default)\n    if (this.state !== nextState) {\n        return true\n    }\n    // update if props are shallowly not equal, inspired by PureRenderMixin\n    // we could return just 'false' here, and avoid the `skipRender` checks etc\n    // however, it is nicer if lifecycle events are triggered like usually,\n    // so we return true here if props are shallowly modified.\n    return !shallowEqual(this.props, nextProps)\n}\n\nfunction createObservablePropDescriptor(key: \"props\" | \"state\" | \"context\") {\n    return {\n        configurable: true,\n        enumerable: true,\n        get() {\n            const admin = getAdministration(this)\n            const derivation = _getGlobalState().trackingDerivation\n            if (derivation && derivation !== admin.reaction) {\n                throw new Error(\n                    `[mobx-react] Cannot read \"${admin.name}.${key}\" in a reactive context, as it isn't observable.\n                    Please use component lifecycle method to copy the value into a local observable first.\n                    See https://github.com/mobxjs/mobx/blob/main/packages/mobx-react/README.md#note-on-using-props-and-state-in-derivations`\n                )\n            }\n            return admin[key]\n        },\n        set(value) {\n            getAdministration(this)[key] = value\n        }\n    }\n}\n","import * as React from \"react\"\nimport { observer as observerLite } from \"mobx-react-lite\"\n\nimport { makeClassComponentObserver } from \"./observerClass\"\nimport { IReactComponent } from \"./types/IReactComponent\"\n\n/**\n * Observer function / decorator\n */\nexport function observer<T extends IReactComponent>(component: T, context: ClassDecoratorContext): void\nexport function observer<T extends IReactComponent>(component: T): T\nexport function observer<T extends IReactComponent>(component: T, context?: ClassDecoratorContext): T {\n    if (context && context.kind !== \"class\") {\n        throw new Error(\"The @observer decorator can be used on classes only\")\n    }\n    if (component[\"isMobxInjector\"] === true) {\n        console.warn(\n            \"Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`\"\n        )\n    }\n\n    if (\n        Object.prototype.isPrototypeOf.call(React.Component, component) ||\n        Object.prototype.isPrototypeOf.call(React.PureComponent, component)\n    ) {\n        // Class component\n        return makeClassComponentObserver(component as React.ComponentClass<any, any>) as T\n    } else {\n        // Function component\n        return observerLite(component as React.FunctionComponent<any>) as T\n    }\n}\n","import React from \"react\"\nimport { patch } from \"./utils/utils\"\n\nconst reactMajorVersion = Number.parseInt(React.version.split(\".\")[0])\nlet warnedAboutDisposeOnUnmountDeprecated = false\n\ntype Disposer = () => void\n\nconst protoStoreKey = Symbol(\"disposeOnUnmountProto\")\nconst instStoreKey = Symbol(\"disposeOnUnmountInst\")\n\nfunction runDisposersOnWillUnmount() {\n    ;[...(this[protoStoreKey] || []), ...(this[instStoreKey] || [])].forEach(propKeyOrFunction => {\n        const prop =\n            typeof propKeyOrFunction === \"string\" ? this[propKeyOrFunction] : propKeyOrFunction\n        if (prop !== undefined && prop !== null) {\n            if (Array.isArray(prop)) prop.map(f => f())\n            else prop()\n        }\n    })\n}\n\n/**\n * @deprecated `disposeOnUnmount` is not compatible with React 18 and higher.\n */\nexport function disposeOnUnmount(target: React.Component<any, any>, propertyKey: PropertyKey): void\n\n/**\n * @deprecated `disposeOnUnmount` is not compatible with React 18 and higher.\n */\nexport function disposeOnUnmount<TF extends Disposer | Array<Disposer>>(\n    target: React.Component<any, any>,\n    fn: TF\n): TF\n\n/**\n * @deprecated `disposeOnUnmount` is not compatible with React 18 and higher.\n */\nexport function disposeOnUnmount(\n    target: React.Component<any, any>,\n    propertyKeyOrFunction: PropertyKey | Disposer | Array<Disposer>\n): PropertyKey | Disposer | Array<Disposer> | void {\n    if (Array.isArray(propertyKeyOrFunction)) {\n        return propertyKeyOrFunction.map(fn => disposeOnUnmount(target, fn))\n    }\n\n    if (!warnedAboutDisposeOnUnmountDeprecated) {\n        if (reactMajorVersion >= 18) {\n            console.error(\n                \"[mobx-react] disposeOnUnmount is not compatible with React 18 and higher. Don't use it.\"\n            )\n        } else {\n            console.warn(\n                \"[mobx-react] disposeOnUnmount is deprecated. It won't work correctly with React 18 and higher.\"\n            )\n        }\n        warnedAboutDisposeOnUnmountDeprecated = true\n    }\n\n    const c = Object.getPrototypeOf(target).constructor\n    const c2 = Object.getPrototypeOf(target.constructor)\n    // Special case for react-hot-loader\n    const c3 = Object.getPrototypeOf(Object.getPrototypeOf(target))\n    if (\n        !(\n            c === React.Component ||\n            c === React.PureComponent ||\n            c2 === React.Component ||\n            c2 === React.PureComponent ||\n            c3 === React.Component ||\n            c3 === React.PureComponent\n        )\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\"\n        )\n    }\n\n    if (\n        typeof propertyKeyOrFunction !== \"string\" &&\n        typeof propertyKeyOrFunction !== \"function\" &&\n        !Array.isArray(propertyKeyOrFunction)\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\"\n        )\n    }\n\n    // decorator's target is the prototype, so it doesn't have any instance properties like props\n    const isDecorator = typeof propertyKeyOrFunction === \"string\"\n\n    // add property key / function we want run (disposed) to the store\n    const componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey]\n    const store = isDecorator\n        ? // decorators are added to the prototype store\n          target[protoStoreKey] || (target[protoStoreKey] = [])\n        : // functions are added to the instance store\n          target[instStoreKey] || (target[instStoreKey] = [])\n\n    store.push(propertyKeyOrFunction)\n\n    // tweak the component class componentWillUnmount if not done already\n    if (!componentWasAlreadyModified) {\n        patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount)\n    }\n\n    // return the disposer as is if invoked as a non decorator\n    if (typeof propertyKeyOrFunction !== \"string\") {\n        return propertyKeyOrFunction\n    }\n}\n","import { observable } from \"mobx\"\nimport { Component } from \"react\"\n\nif (!Component) {\n    throw new Error(\"mobx-react requires React to be available\")\n}\n\nif (!observable) {\n    throw new Error(\"mobx-react requires mobx to be available\")\n}\n\nexport {\n    Observer,\n    useObserver,\n    useAsObservableSource,\n    useLocalStore,\n    isUsingStaticRendering,\n    useStaticRendering,\n    enableStaticRendering,\n    observerBatching,\n    useLocalObservable\n} from \"mobx-react-lite\"\n\nexport { observer } from \"./observer\"\n\nexport { MobXProviderContext, Provider, ProviderProps } from \"./Provider\"\nexport { inject } from \"./inject\"\nexport { disposeOnUnmount } from \"./disposeOnUnmount\"\nexport { PropTypes } from \"./propTypes\"\nexport { IWrappedComponent } from \"./types/IWrappedComponent\"\n","/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n"],"names":["useState","Error","makeObservable","defaultNoopBatch","callback","printDebugValue","v","getDependencyTree","globalIsUsingStaticRendering","isUsingStaticRendering","TimerBasedFinalizationRegistry","finalize","_this","Object","defineProperty","Map","maxAge","clearTimeout","sweepTimeout","undefined","now","Date","registrations","forEach","registration","token","registeredAt","value","delete","size","scheduleSweep","sweep","target","this","set","setTimeout","observerFinalizationRegistry","FinalizationRegistry","adm","_a","reaction","dispose","createReaction","Reaction","concat","name","stateVersion","Symbol","onStoreChange","call","useObserver","render","baseComponentName","admRef","React","current","adm_1","subscribe","unregister","getSnapshot","renderResult","exception","register","useSyncExternalStore","track","e","hasSymbol","for","isFunctionNameConfigurable","_b","getOwnPropertyDescriptor","configurable","ReactForwardRefSymbol","forwardRef","props","ReactMemoSymbol","memo","observer","baseComponent","options","useForwardRef","displayName","base","observerComponent","ref","writable","contextTypes","keys","key","hoistBlackList","reactionScheduler","$$typeof","compare","type","batch","configure","is","x","y","mobxMixins","mobxPatchedDefinition","wrapper","realMethod","mixins","args","Array","_len","_key","arguments","locks","retVal","apply","methods","mx","wrapFunction","_len2","_key2","patch","methodName","mixinMethod","methodMixins","getMixins","indexOf","push","oldDefinition","originalMethod","newDefinition","createDefinition","enumerable","wrappedFunc","_ref","get","administrationSymbol","isMobXReactObserverSymbol","getAdministration","component","_component$administra","mounted","reactionInvalidatedBeforeMount","forceUpdate","getDisplayName","constructor","state","context","componentClass","createReactiveRender","originalRender","boundOriginalRender","bind","admin","error","_admin$reaction2","_observerFinalizationRegistry","_allowStateChanges","observerSCU","nextProps","nextState","console","warn","objA","objB","keysA","keysB","length","i","hasOwnProperty","shallowEqual","kind","prototype","isPrototypeOf","Component","PureComponent","componentWillReact","shouldComponentUpdate","_displayName","originalComponentDidMount","componentDidMount","_admin$reaction","makeClassComponentObserver","observer$1","React__default","split","observable","require","k","a","b","l","m","useEffect","n","useLayoutEffect","p","useDebugValue","r","d","f","u","window","document","createElement","inst","c","g","exports","module"],"sourceRoot":""}